---
title: "[å°ãƒã‚¿] é–¢æ•°ã«ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ å¼•æ•°ã‚’è¤‡æ•°å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã®ä¸€ä¾‹"
emoji: "ğŸ¦€"
type: "tech"
topics: ["rust"]
published: true
---

# ã¯ã˜ã‚ã«

åˆå­¦è€…å‘ã‘ã§ã™ã€‚

[Rustã§ä½œã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èª](https://gihyo.jp/book/2024/978-4-297-14192-9)ã®é …2.5ã‚’å†™çµŒä¸­ã€é–¢æ•°ã«ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’2ç¨®é¡æ˜ç¤ºã—ã¦ã„ã‚‹ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã—ãŸã€‚ãªãœãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’2ã¤æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã‹ç–‘å•ã«æ„Ÿã˜ã€æƒãˆãŸã¨ã“ã‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æŒ‡å®šã«æ„å‘³ãŒã‚ã‚‹ã“ã¨ãŒåˆ†ã‹ã£ãŸãŸã‚èª¿æŸ»ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚


# å¤‰æ›´ç®‡æ‰€ã¨ã‚¨ãƒ©ãƒ¼å†…å®¹

```diff:å¤‰æ›´ç®‡æ‰€
-fn parse_block<'src, 'a>(input: &'a [&'src str]) -> (Value<'src>, &'a [&'src str]) {
+fn parse_block<'src>(input: &'src [&'src str]) -> (Value<'src>, &'src [&'src str]) {
     let mut tokens = vec![];
     let mut words = input;
```


```bash:ã‚¨ãƒ©ãƒ¼å†…å®¹
   Compiling rustack v0.1.0 (/Users/shuntaka/repos/github.com/shuntaka9576/rust-playground/rustack)
error[E0515]: cannot return value referencing local variable `input`
  --> src/main.rs:39:5
   |
12 |     let mut words = &input[..];
   |                      ----- `input` is borrowed here
...
39 |     stack
   |     ^^^^^ returns a value referencing data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `rustack` (bin "rustack") due to 1 previous error
```

> returns a value referencing data owned by the current function

> ç¾åœ¨ã®é–¢æ•°ãŒæ‰€æœ‰ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’å‚ç…§ã™ã‚‹å€¤ã‚’è¿”ã—ã¦ã„ã¾ã™

inputãŒã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ã¨ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚inputã¯Vecãªã®ã§ãƒ’ãƒ¼ãƒ—ã‚’å‰²ã‚Šå½“ã¦ã¦ã„ã¦ãã“ã‹ã‚‰lineã‚’å‚ç…§ã—ã¦ã„ã‚‹å½¢ã ã¨æ€ã„ã¾ã™ã€‚
å˜ã«inputãŒãƒ‰ãƒ­ãƒƒãƒ—ã—ãŸã‚‰å½“ç„¶wordã‚‚stackã‚‚å‚ç…§ãŒæ¶ˆãˆã‚‹ã®ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒèµ·ãã‚‹ã“ã¨ã¯ç†è§£å‡ºæ¥ã¾ã™ã€‚

```
word(&[&str]) -> input(Vec<&str>) -> line(&str)
```


:::details æ­£ã—ãå‹•ä½œã™ã‚‹ã‚³ãƒ¼ãƒ‰å…¨æ–‡


```rust
use core::panic;

fn main() {
    for line in std::io::stdin().lines().flatten() {
        parse(&line);
    }
}

fn parse(line: &str) -> Vec<Value> {
    let mut stack = vec![];
    let input: Vec<_> = line.split(" ").collect();
    let mut words = &input[..];

    while let Some((&word, mut rest)) = words.split_first() {
        if words.is_empty() {
            break;
        }

        if word == "{" {
            let value;
            (value, rest) = parse_block(rest);
            stack.push(value);
        } else if let Ok(parsed) = word.parse::<i32>() {
            stack.push(Value::Num(parsed));
        } else {
            match word {
                "+" => add(&mut stack),
                "-" => sub(&mut stack),
                "*" => mul(&mut stack),
                "/" => div(&mut stack),
                _ => panic!("{word:?} could not be parsed"),
            }
        }
        words = rest;
    }

    println!("stack: {stack:?}");

    stack
}

fn parse_block<'src, 'a>(input: &'a [&'src str]) -> (Value<'src>, &'a [&'src str]) {
    let mut tokens = vec![];
    let mut words = input;

    while let Some((&word, mut rest)) = words.split_first() {
        if word.is_empty() {
            break;
        }

        if word == "{" {
            let value;
            (value, rest) = parse_block(rest);
            tokens.push(value)
        } else if word == "}" {
            return (Value::Block(tokens), rest);
        } else if let Ok(value) = word.parse::<i32>() {
            tokens.push(Value::Num(value));
        } else {
            tokens.push(Value::Op(word));
        }

        words = rest;
    }

    (Value::Block(tokens), words)
}

#[derive(Debug, PartialEq, Eq)]
enum Value<'src> {
    Num(i32),
    Op(&'src str),
    Block(Vec<Value<'src>>),
}

impl<'src> Value<'src> {
    fn as_num(&self) -> i32 {
        match self {
            Self::Num(val) => *val,
            _ => panic!("Value is not a number"),
        }
    }
}

fn add(stack: &mut Vec<Value>) {
    let lhs = stack.pop().unwrap().as_num();
    let rhs = stack.pop().unwrap().as_num();

    stack.push(Value::Num(lhs + rhs))
}

fn sub(stack: &mut Vec<Value>) {
    let lhs = stack.pop().unwrap().as_num();
    let rhs = stack.pop().unwrap().as_num();

    stack.push(Value::Num(lhs - rhs))
}

fn mul(stack: &mut Vec<Value>) {
    let lhs = stack.pop().unwrap().as_num();
    let rhs = stack.pop().unwrap().as_num();

    stack.push(Value::Num(lhs * rhs))
}

fn div(stack: &mut Vec<Value>) {
    let lhs = stack.pop().unwrap().as_num();
    let rhs = stack.pop().unwrap().as_num();

    stack.push(Value::Num(lhs / rhs))
}

#[cfg(test)]
mod test {
    use super::{parse, Value::*};

    #[test]
    fn test_group() {
        assert_eq!(
            parse("1 2 + { 3 4 }"),
            vec![Num(3), Block(vec![Num(3), Num(4)])]
        )
    }
}
```
:::


# ç†ç”±

å‰ã®ã‚³ãƒ¼ãƒ‰ã ã¨è¡Œæ•°ãŒå¤šã„ã®ã§æœ€å°ã‚³ãƒ¼ãƒ‰ã§è€ƒãˆã¦ã¿ã¾ã™ã€‚ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã‚‚ã‚¨ãƒ©ãƒ¼ã¯å†ç¾ã—ã¾ã™ã€‚


```rust
fn main() {
    let line = "1 str 2";
    let stack = parse(line);
    println!("stack:{stack:?}");
}

fn parse(line: &str) -> Vec<Value> {
    let mut stack = vec![];
    let input: Vec<_> = line.split(" ").collect();
    let words = &input[..];

    let (_word, rest) = words.split_first().expect("word is empty");
    let (value, _rest) = parse_block(rest);

    stack.push(value);

    stack
}

// ã‚¨ãƒ©ãƒ¼ãŒèµ·ããªã„è¨˜è¿°
// fn parse_block<'src, 'a>(input: &'a [&'src str]) -> (Value<'src>, &'a [&'src str]) {
fn parse_block<'src>(input: &'src [&'src str]) -> (Value<'src>, &[&'src str]) {
    let (&first, rest) = input.split_first().expect("Input is empty");
    if first == "str" {
        (Value::Str(first), rest)
    } else {
        let num = first.parse::<i32>().expect("Failed to parse number");
        (Value::Num(num), rest)
    }
}

#[derive(Debug, PartialEq, Eq)]
enum Value<'src> {
    Num(i32),
    Str(&'src str),
}
```


parseé–¢æ•°ã®inputã¯ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§ç ´æ£„ã•ã‚Œã¾ã™ã€‚diffã®ã‚ˆã†ã«ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æƒãˆã¦ã—ã¾ã†ã¨ã€inputã¨valueã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒåŒã˜ã“ã¨ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ä¼ãˆã¦ã—ã¾ã„ã¾ã™ã€‚inputã¯å‰è¿°ã®é€šã‚Šã€parseé–¢æ•°ã§ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã®ã§`é–¢æ•°ãŒæ‰€æœ‰ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’å‚ç…§ã™ã‚‹å€¤`ã‚’è¿”ã™ã“ã¨ã«ãªã‚Šã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚
å‚ç…§å…ƒã‚’ãŸã©ã‚‹ã¨lineã¯mainã‚¹ã‚³ãƒ¼ãƒ—ãªã®ã§ã€stackã«å…¥ã‚Œã‚‹valueã¯inputã‚ˆã‚Šãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒé•·ãã¦å•é¡Œãªã„ã§ã™ã€‚


```diff:å¤‰æ›´ç®‡æ‰€
-fn parse_block<'src, 'a>(input: &'a [&'src str]) -> (Value<'src>, &'a [&'src str]) {
+fn parse_block<'src>(input: &'src [&'src str]) -> (Value<'src>, &'src [&'src str]) {
     let mut tokens = vec![];
     let mut words = input;
```
ä»¥ä¸Šã‚ˆã‚Šã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æŒ‡å®šå­ã¯åˆ†ã‘ã¦æ›¸ãå¿…è¦ãŒã‚ã‚Šã¾ã—ãŸã€‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯ã€ã©ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§å®šç¾©ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’å‚ç…§ã—ã¦ã„ã‚‹ã®ã‹ã‚’æ„è­˜ã™ã‚‹ã¨æ­£ã—ãæŒ‡å®šå‡ºæ¥ãã†ãªæ°—ãŒã—ã¦ã„ã¾ã™ã€‚ä»Šå›ã§ã™ã¨å…ƒã¯ãƒ¡ã‚¤ãƒ³ã‚¹ã‚³ãƒ¼ãƒ—ã®lineã§ã™ã®ã§ã€parse_blockã‚ˆã‚Šé•·ã„æŒ‡å®šãŒå¯èƒ½ã¨è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚

å…ƒã‚³ãƒ¼ãƒ‰ã«ã¯parseã«ã‚‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æŒ‡å®šå­ãŒã¤ã„ã¦ã„ã¾ã™ã€‚ç§ã®ã‚µãƒ³ãƒ—ãƒ«ã§ã¯æ›¸ã„ã¦ã¾ã›ã‚“ãŒã€ã“ã‚Œã¯å†…éƒ¨çš„ã«è£œå®Œã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ã€‚

https://github.com/msakuta/rustack/blob/19081dc457e9913f9ffad6ea3c287c13079a868e/examples/03-group.rs#L23



# ã•ã„ã”ã«

æ›¸ç±ã«ã¯ `ã“ã‚Œã¯ã‚½ãƒ¼ã‚¹æ–‡å­—åˆ—ã‚ˆã‚ŠçŸ­å‘½ã§ã‚ã‚Šã†ã‚‹ãŸã‚ã€ç•°ãªã‚‹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æŒ‡å®šã—ã¦ã„ã¾ã™` ã¨æ›¸ã‹ã‚Œã¦ã„ã‚‹é€šã‚Šã§ã—ãŸã€‚èª­ã‚“ã ã ã‘ã§ã¯ãƒ”ãƒ³ã¨ãã¦ã¾ã›ã‚“ã§ã—ãŸãŒã€è‰²ã€…å¤‰æ›´ã—ã€ç´å¾—ãŒã„ãã¾ã—ãŸã€‚ãƒˆãƒ¬ã‚¤ãƒˆã«ã¤ã„ã¦ã„ã‚‹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨é€£å‹•ã—ã¦ã„ã‚‹ã®ã‹ã¯ã‚ˆãåˆ†ã‹ã£ã¦ã„ã¾ã›ã‚“ğŸ¥º

ã¾ã ã¾ã åˆå¿ƒè€…ãªã®ã§å¤šåˆ†ã«å‹˜é•ã„ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚å¿Œæ†šãªã„æ„è¦‹ã‚’é ‚ã‘ãŸã‚‰å¹¸ã„ã§ã™ã€‚
