---
title: "[小ネタ] 関数にライフタイム引数を複数定義する必要がある場合の一例"
emoji: "🦀"
type: "tech"
topics: ["rust"]
published: true
---

# はじめに

初学者向けです。

[Rustで作るプログラミング言語](https://gihyo.jp/book/2024/978-4-297-14192-9)の項2.5を写経中、関数にライフタイムを2種類明示しているコードがありました。なぜライフタイムを2つ指定する必要があるのか疑問に感じ、揃えたところコンパイルエラーが発生しました。指定に意味があることが分かったため調査することにしました。


# 変更箇所とエラー内容

```diff:変更箇所
-fn parse_block<'src, 'a>(input: &'a [&'src str]) -> (Value<'src>, &'a [&'src str]) {
+fn parse_block<'src>(input: &'src [&'src str]) -> (Value<'src>, &'src [&'src str]) {
     let mut tokens = vec![];
     let mut words = input;
```


```bash:エラー内容
   Compiling rustack v0.1.0 (/Users/shuntaka/repos/github.com/shuntaka9576/rust-playground/rustack)
error[E0515]: cannot return value referencing local variable `input`
  --> src/main.rs:39:5
   |
12 |     let mut words = &input[..];
   |                      ----- `input` is borrowed here
...
39 |     stack
   |     ^^^^^ returns a value referencing data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `rustack` (bin "rustack") due to 1 previous error
```

> returns a value referencing data owned by the current function

> 現在の関数が所有するデータを参照する値を返しています

inputがスコープを抜けるとドロップされます。inputはVecなのでヒープを割り当てていてそこからlineを参照している形だと思います。
単にinputがドロップしたら当然wordもstackも参照が消えるのでコンパイルエラーが起きることは理解出来ます。

```
word(&[&str]) -> input(Vec<&str>) -> line(&str)
```


:::details 正しく動作するコード全文


```rust
use core::panic;

fn main() {
    for line in std::io::stdin().lines().flatten() {
        parse(&line);
    }
}

fn parse(line: &str) -> Vec<Value> {
    let mut stack = vec![];
    let input: Vec<_> = line.split(" ").collect();
    let mut words = &input[..];

    while let Some((&word, mut rest)) = words.split_first() {
        if words.is_empty() {
            break;
        }

        if word == "{" {
            let value;
            (value, rest) = parse_block(rest);
            stack.push(value);
        } else if let Ok(parsed) = word.parse::<i32>() {
            stack.push(Value::Num(parsed));
        } else {
            match word {
                "+" => add(&mut stack),
                "-" => sub(&mut stack),
                "*" => mul(&mut stack),
                "/" => div(&mut stack),
                _ => panic!("{word:?} could not be parsed"),
            }
        }
        words = rest;
    }

    println!("stack: {stack:?}");

    stack
}

fn parse_block<'src, 'a>(input: &'a [&'src str]) -> (Value<'src>, &'a [&'src str]) {
    let mut tokens = vec![];
    let mut words = input;

    while let Some((&word, mut rest)) = words.split_first() {
        if word.is_empty() {
            break;
        }

        if word == "{" {
            let value;
            (value, rest) = parse_block(rest);
            tokens.push(value)
        } else if word == "}" {
            return (Value::Block(tokens), rest);
        } else if let Ok(value) = word.parse::<i32>() {
            tokens.push(Value::Num(value));
        } else {
            tokens.push(Value::Op(word));
        }

        words = rest;
    }

    (Value::Block(tokens), words)
}

#[derive(Debug, PartialEq, Eq)]
enum Value<'src> {
    Num(i32),
    Op(&'src str),
    Block(Vec<Value<'src>>),
}

impl<'src> Value<'src> {
    fn as_num(&self) -> i32 {
        match self {
            Self::Num(val) => *val,
            _ => panic!("Value is not a number"),
        }
    }
}

fn add(stack: &mut Vec<Value>) {
    let lhs = stack.pop().unwrap().as_num();
    let rhs = stack.pop().unwrap().as_num();

    stack.push(Value::Num(lhs + rhs))
}

fn sub(stack: &mut Vec<Value>) {
    let lhs = stack.pop().unwrap().as_num();
    let rhs = stack.pop().unwrap().as_num();

    stack.push(Value::Num(lhs - rhs))
}

fn mul(stack: &mut Vec<Value>) {
    let lhs = stack.pop().unwrap().as_num();
    let rhs = stack.pop().unwrap().as_num();

    stack.push(Value::Num(lhs * rhs))
}

fn div(stack: &mut Vec<Value>) {
    let lhs = stack.pop().unwrap().as_num();
    let rhs = stack.pop().unwrap().as_num();

    stack.push(Value::Num(lhs / rhs))
}

#[cfg(test)]
mod test {
    use super::{parse, Value::*};

    #[test]
    fn test_group() {
        assert_eq!(
            parse("1 2 + { 3 4 }"),
            vec![Num(3), Block(vec![Num(3), Num(4)])]
        )
    }
}
```
:::


# 理由

前のコードだと行数が多いので最小コードで考えてみます。このコードでもエラーは再現します。


```rust
fn main() {
    let line = "1 str 2";
    let stack = parse(line);
    println!("stack:{stack:?}");
}

fn parse(line: &str) -> Vec<Value> {
    let mut stack = vec![];
    let input: Vec<_> = line.split(" ").collect();
    let words = &input[..];

    let (_word, rest) = words.split_first().expect("word is empty");
    let (value, _rest) = parse_block(rest);

    stack.push(value);

    stack
}

// エラーが起きない記述
// fn parse_block<'src, 'a>(input: &'a [&'src str]) -> (Value<'src>, &'a [&'src str]) {
fn parse_block<'src>(input: &'src [&'src str]) -> (Value<'src>, &[&'src str]) {
    let (&first, rest) = input.split_first().expect("Input is empty");
    if first == "str" {
        (Value::Str(first), rest)
    } else {
        let num = first.parse::<i32>().expect("Failed to parse number");
        (Value::Num(num), rest)
    }
}

#[derive(Debug, PartialEq, Eq)]
enum Value<'src> {
    Num(i32),
    Str(&'src str),
}
```


parse関数のinputはメソッドのスコープで破棄されます。diffのようにライフタイムを揃えてしまうと、inputとvalueのライフタイムが同じことをコンパイラに伝えてしまいます。inputは前述の通り、parse関数でドロップするので`関数が所有するデータを参照する値`を返すことになりコンパイルエラーが発生します。
参照元をたどるとlineはmainスコープなので、stackに入れるvalueはinputよりライフタイムが長くて問題ないです。


```diff:変更箇所
-fn parse_block<'src, 'a>(input: &'a [&'src str]) -> (Value<'src>, &'a [&'src str]) {
+fn parse_block<'src>(input: &'src [&'src str]) -> (Value<'src>, &'src [&'src str]) {
     let mut tokens = vec![];
     let mut words = input;
```
以上より、ライフタイム指定子は分けて書く必要がありました。ライフタイムは、どのスコープで定義されたデータを参照しているのかを意識すると正しく指定出来そうな気がしています。今回ですと元はメインスコープのlineですので、parse_blockより長い指定が可能と考えられます。

元コードにはparseにもライフタイム指定子がついています。私のサンプルでは書いてませんが、これは内部的に補完されていることが考えられます。

https://github.com/msakuta/rustack/blob/19081dc457e9913f9ffad6ea3c287c13079a868e/examples/03-group.rs#L23



# さいごに

書籍には `これはソース文字列より短命でありうるため、異なるライフタイムを指定しています` と書かれている通りでした。読んだだけではピンときてませんでしたが、色々変更し、納得がいきました。トレイトについているライフタイムと連動しているのかはよく分かっていません🥺

まだまだ初心者なので多分に勘違いを含む可能性があります。忌憚ない意見を頂けたら幸いです。
